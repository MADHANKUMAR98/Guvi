Hereâ€™s an expanded Spring Boot project structure for your electricity billing system with proper layering (POJO, Controller, Service, and DAO) and database integration with Oracle. Each functionality is based on user roles: **Admin** and **Customer**, with separate login flows.

### 1. **Database Schema** (Oracle)

```sql
-- Customers Table
CREATE TABLE CUSTOMERS (
    CUSTOMER_ID VARCHAR2(20) PRIMARY KEY,
    NAME VARCHAR2(100),
    EMAIL VARCHAR2(100),
    PHONE VARCHAR2(15),
    PASSWORD VARCHAR2(100),
    ADDRESS VARCHAR2(255),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Bills Table
CREATE TABLE BILLS (
    BILL_ID VARCHAR2(20) PRIMARY KEY,
    BILL_MONTH VARCHAR2(20),
    ELECTRICITY_USED NUMBER,
    AMOUNT NUMBER(10, 2),
    STATUS VARCHAR2(20),
    CUSTOMER_ID VARCHAR2(20),
    FOREIGN KEY (CUSTOMER_ID) REFERENCES CUSTOMERS(CUSTOMER_ID)
);

-- Payments Table
CREATE TABLE PAYMENTS (
    PAYMENT_ID VARCHAR2(20) PRIMARY KEY,
    PAYMENT_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    AMOUNT_PAID NUMBER(10, 2),
    PAYMENT_MODE VARCHAR2(20),
    BILL_ID VARCHAR2(20),
    FOREIGN KEY (BILL_ID) REFERENCES BILLS(BILL_ID)
);

-- Admins Table
CREATE TABLE ADMINS (
    ADMIN_ID VARCHAR2(20) PRIMARY KEY,
    USERNAME VARCHAR2(100),
    PASSWORD VARCHAR2(100)
);
```

---

### 2. **Entities (POJO Layer)**

#### 2.1. `Customer.java`
```java
@Entity
@Table(name = "CUSTOMERS")
public class Customer {
    @Id
    private String customerId;
    
    private String name;
    private String email;
    private String phone;
    private String password;
    private String address;

    @CreationTimestamp
    private LocalDateTime createdAt;

    // Getters and Setters
}
```

#### 2.2. `Admin.java`
```java
@Entity
@Table(name = "ADMINS")
public class Admin {
    @Id
    private String adminId;
    
    private String username;
    private String password;

    // Getters and Setters
}
```

#### 2.3. `Bill.java`
```java
@Entity
@Table(name = "BILLS")
public class Bill {
    @Id
    private String billId;
    
    private String billMonth;
    private double electricityUsed;
    private double amount;
    private String status;

    @ManyToOne
    @JoinColumn(name = "CUSTOMER_ID")
    private Customer customer;

    // Getters and Setters
}
```

#### 2.4. `Payment.java`
```java
@Entity
@Table(name = "PAYMENTS")
public class Payment {
    @Id
    private String paymentId;
    
    private double amountPaid;
    private String paymentMode;

    @CreationTimestamp
    private LocalDateTime paymentDate;

    @ManyToOne
    @JoinColumn(name = "BILL_ID")
    private Bill bill;

    // Getters and Setters
}
```

---

### 3. **DAO Layer (Repositories)**

#### 3.1. `CustomerRepository.java`
```java
@Repository
public interface CustomerRepository extends JpaRepository<Customer, String> {
    Optional<Customer> findByEmailAndPassword(String email, String password);
}
```

#### 3.2. `AdminRepository.java`
```java
@Repository
public interface AdminRepository extends JpaRepository<Admin, String> {
    Optional<Admin> findByUsernameAndPassword(String username, String password);
}
```

#### 3.3. `BillRepository.java`
```java
@Repository
public interface BillRepository extends JpaRepository<Bill, String> {
    List<Bill> findByCustomerAndStatus(Customer customer, String status);
}
```

#### 3.4. `PaymentRepository.java`
```java
@Repository
public interface PaymentRepository extends JpaRepository<Payment, String> {
    List<Payment> findByBill(Bill bill);
}
```

---

### 4. **Service Layer**

#### 4.1. `AdminService.java`
```java
@Service
public interface AdminService {
    Admin login(String username, String password);
    void addCustomer(Customer customer);
    void editCustomer(Customer customer);
    void deleteCustomer(String customerId);
    Bill generateBill(Bill bill);
    List<Payment> viewCustomerPayments(String customerId);
    List<Bill> viewPendingPayments(String customerId);
}
```

#### 4.2. `AdminServiceImpl.java`
```java
@Service
public class AdminServiceImpl implements AdminService {

    @Autowired
    private AdminRepository adminRepo;

    @Autowired
    private CustomerRepository customerRepo;

    @Autowired
    private BillRepository billRepo;

    @Autowired
    private PaymentRepository paymentRepo;

    @Override
    public Admin login(String username, String password) {
        return adminRepo.findByUsernameAndPassword(username, password)
                .orElseThrow(() -> new RuntimeException("Invalid admin credentials"));
    }

    @Override
    public void addCustomer(Customer customer) {
        customerRepo.save(customer);
    }

    @Override
    public void editCustomer(Customer customer) {
        customerRepo.save(customer);
    }

    @Override
    public void deleteCustomer(String customerId) {
        customerRepo.deleteById(customerId);
    }

    @Override
    public Bill generateBill(Bill bill) {
        return billRepo.save(bill);
    }

    @Override
    public List<Payment> viewCustomerPayments(String customerId) {
        Customer customer = customerRepo.findById(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found"));
        return paymentRepo.findByBillCustomer(customer);
    }

    @Override
    public List<Bill> viewPendingPayments(String customerId) {
        Customer customer = customerRepo.findById(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found"));
        return billRepo.findByCustomerAndStatus(customer, "Pending");
    }
}
```

#### 4.3. `CustomerService.java`
```java
@Service
public interface CustomerService {
    Customer login(String email, String password);
    Payment makePayment(Payment payment);
    List<Payment> viewPaymentHistory(String customerId);
}
```

#### 4.4. `CustomerServiceImpl.java`
```java
@Service
public class CustomerServiceImpl implements CustomerService {

    @Autowired
    private CustomerRepository customerRepo;

    @Autowired
    private BillRepository billRepo;

    @Autowired
    private PaymentRepository paymentRepo;

    @Override
    public Customer login(String email, String password) {
        return customerRepo.findByEmailAndPassword(email, password)
                .orElseThrow(() -> new RuntimeException("Invalid customer credentials"));
    }

    @Override
    public Payment makePayment(Payment payment) {
        Bill bill = billRepo.findById(payment.getBill().getBillId())
                .orElseThrow(() -> new RuntimeException("Bill not found"));
        payment.setBill(bill);
        paymentRepo.save(payment);
        bill.setStatus("Paid");
        billRepo.save(bill);
        return payment;
    }

    @Override
    public List<Payment> viewPaymentHistory(String customerId) {
        Customer customer = customerRepo.findById(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found"));
        return paymentRepo.findByBillCustomer(customer);
    }
}
```

---

### 5. **Controllers Layer**

#### 5.1. `AdminController.java`
```java
@RestController
@RequestMapping("/admin")
public class AdminController {

    @Autowired
    private AdminService adminService;

    @PostMapping("/login")
    public ResponseEntity<Admin> login(@RequestBody Map<String, String> credentials) {
        Admin admin = adminService.login(credentials.get("username"), credentials.get("password"));
        return ResponseEntity.ok(admin);
    }

    @PostMapping("/addCustomer")
    public ResponseEntity<Customer> addCustomer(@RequestBody Customer customer) {
        adminService.addCustomer(customer);
        return ResponseEntity.ok(customer);
    }

    @PutMapping("/editCustomer")
    public ResponseEntity<Customer> editCustomer(@RequestBody Customer customer) {
        adminService.editCustomer(customer);
        return ResponseEntity.ok(customer);
    }

    @DeleteMapping("/deleteCustomer/{customerId}")
    public ResponseEntity<String> deleteCustomer(@PathVariable String customerId) {
        adminService.deleteCustomer(customerId);
        return ResponseEntity.ok("Customer deleted");
    }

    @PostMapping("/generateBill")
    public ResponseEntity<Bill> generateBill(@RequestBody Bill bill) {
        Bill generatedBill = adminService.generateBill(bill);
        return ResponseEntity.ok(generatedBill);
    }

    @GetMapping("/viewPayments/{customerId}")
    public ResponseEntity<List<Payment>> viewPayments(@PathVariable String customerId) {
        List<Payment> payments = adminService.viewCustomerPayments(customerId);
        return ResponseEntity.ok(payments);
    }

    @GetMapping("/viewPendingPayments/{customerId}")
    public ResponseEntity<List<Bill>> viewPendingPayments(@PathVariable String customerId) {
        List<Bill> pendingBills = adminService.viewPendingPayments(customerId);
        return ResponseEntity.ok(pendingBills);
    }
}
```

#### 5.2. `CustomerController.java`
```java
@RestController
@RequestMapping("/customer")
public class CustomerController {

    @Autowired
    private CustomerService customerService;

    @PostMapping("/login")
    public ResponseEntity<Customer> login(@RequestBody Map<String, String> credentials) {
        Customer customer = customerService.login(credentials.get("email"), credentials.get("password"));

```java
        return ResponseEntity.ok(customer);
    }

    @PostMapping("/makePayment")
    public ResponseEntity<Payment> makePayment(@RequestBody Payment payment) {
        Payment newPayment = customerService.makePayment(payment);
        return ResponseEntity.ok(newPayment);
    }

    @GetMapping("/paymentHistory/{customerId}")
    public ResponseEntity<List<Payment>> viewPaymentHistory(@PathVariable String customerId) {
        List<Payment> paymentHistory = customerService.viewPaymentHistory(customerId);
        return ResponseEntity.ok(paymentHistory);
    }
}
```

---

### **Sample Functionality and Input**

1. **Admin Login Flow:**
   - Admin enters username and password.
   - If valid, admin is authenticated, and the admin can now:
     - Add, edit, or delete customers.
     - Generate bills for a customer by providing the customer's ID and the amount of electricity used.
     - View a customer's payment history or pending payments.

**Sample Input:**
```json
{
  "username": "admin1",
  "password": "adminpass"
}
```

2. **Adding a Customer:**
   - Admin inputs customer details (name, email, phone, address).
   - The new customer is registered in the system.

**Sample Input:**
```json
{
  "customerId": "CUST001",
  "name": "John Doe",
  "email": "johndoe@example.com",
  "phone": "1234567890",
  "password": "password123",
  "address": "1234 Elm Street"
}
```

3. **Customer Login Flow:**
   - Customer enters email and password.
   - Once authenticated, they can:
     - Make payments.
     - View previous payments and electricity consumption history.

**Sample Input:**
```json
{
  "email": "johndoe@example.com",
  "password": "password123"
}
```

4. **Generating a Bill for a Customer:**
   - Admin enters the month, electricity used, and the customer's ID.
   - The system calculates the bill based on predefined rates.

**Sample Input:**
```json
{
  "billId": "BILL001",
  "billMonth": "August",
  "electricityUsed": 350,
  "amount": 700.00,
  "status": "Pending",
  "customerId": "CUST001"
}
```

5. **Making a Payment:**
   - The customer selects a pending bill and pays the amount due.
   - The system captures the payment details and updates the bill's status to "Paid."

**Sample Input:**
```json
{
  "paymentId": "PAY001",
  "amountPaid": 700.00,
  "paymentMode": "Credit Card",
  "billId": "BILL001"
}
```

6. **Viewing Payment History:**
   - Customer requests their payment history.
   - The system returns all payments made by the customer.

**Sample Input:**
```
GET /customer/paymentHistory/CUST001
```

---

### **Relational Mapping in Database**

- **One-to-Many** between `Customer` and `Bill`: Each customer can have multiple bills.
- **Many-to-One** between `Bill` and `Payment`: Each payment corresponds to one bill.

These mappings are represented in the entities using `@ManyToOne` and `@OneToMany` annotations.

---

### **Project Summary**

This Spring Boot project handles both admin and customer flows with a well-structured architecture:
- **Admin Flow:** Managing customers, generating bills, and viewing payments.
- **Customer Flow:** Making payments and viewing their electricity consumption history.
- The system uses Oracle as the database and integrates various entities and relationships to make the system professional and scalable.

Let me know if you need further customization or explanation!








Let's enhance the project by adding an Address entity to the system and improving the payment functionality to include the payment method (e.g., credit card, debit card, etc.). Additionally, weâ€™ll rename the database tables to follow the format EBS_Table_Name.

1. Database Schema (Oracle)
sql
Copy code
-- EBS_CUSTOMERS Table
CREATE TABLE EBS_CUSTOMERS (
    CUSTOMER_ID VARCHAR2(20) PRIMARY KEY,
    NAME VARCHAR2(100),
    EMAIL VARCHAR2(100),
    PHONE VARCHAR2(15),
    PASSWORD VARCHAR2(100),
    ADDRESS_ID VARCHAR2(20),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (ADDRESS_ID) REFERENCES EBS_ADDRESS(ADDRESS_ID)
);

-- EBS_ADDRESS Table
CREATE TABLE EBS_ADDRESS (
    ADDRESS_ID VARCHAR2(20) PRIMARY KEY,
    HOUSE_NUMBER VARCHAR2(10),
    STREET_NAME VARCHAR2(100),
    AREA_NAME VARCHAR2(100),
    CITY VARCHAR2(50),
    STATE VARCHAR2(50),
    PINCODE VARCHAR2(10)
);

-- EBS_BILLS Table
CREATE TABLE EBS_BILLS (
    BILL_ID VARCHAR2(20) PRIMARY KEY,
    BILL_MONTH VARCHAR2(20),
    ELECTRICITY_USED NUMBER,
    AMOUNT NUMBER(10, 2),
    STATUS VARCHAR2(20),
    CUSTOMER_ID VARCHAR2(20),
    FOREIGN KEY (CUSTOMER_ID) REFERENCES EBS_CUSTOMERS(CUSTOMER_ID)
);

-- EBS_PAYMENTS Table
CREATE TABLE EBS_PAYMENTS (
    PAYMENT_ID VARCHAR2(20) PRIMARY KEY,
    PAYMENT_DATE TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    AMOUNT_PAID NUMBER(10, 2),
    PAYMENT_MODE VARCHAR2(20),
    PAYMENT_TYPE VARCHAR2(20), -- New field for payment method
    BILL_ID VARCHAR2(20),
    FOREIGN KEY (BILL_ID) REFERENCES EBS_BILLS(BILL_ID)
);

-- EBS_ADMINS Table
CREATE TABLE EBS_ADMINS (
    ADMIN_ID VARCHAR2(20) PRIMARY KEY,
    USERNAME VARCHAR2(100),
    PASSWORD VARCHAR2(100)
);
2. Entities (POJO Layer)
2.1. Address.java
java
Copy code
@Entity
@Table(name = "EBS_ADDRESS")
public class Address {
    @Id
    private String addressId;

    private String houseNumber;
    private String streetName;
    private String areaName;
    private String city;
    private String state;
    private String pincode;

    // Getters and Setters
}
2.2. Customer.java (Updated with Address)
java
Copy code
@Entity
@Table(name = "EBS_CUSTOMERS")
public class Customer {
    @Id
    private String customerId;

    private String name;
    private String email;
    private String phone;
    private String password;

    @ManyToOne
    @JoinColumn(name = "ADDRESS_ID")
    private Address address;

    @CreationTimestamp
    private LocalDateTime createdAt;

    // Getters and Setters
}
2.3. Payment.java (Updated with Payment Method)
java
Copy code
@Entity
@Table(name = "EBS_PAYMENTS")
public class Payment {
    @Id
    private String paymentId;

    private double amountPaid;
    private String paymentMode;  // E.g., Cash, Credit Card, Debit Card
    private String paymentType;  // New field for type of payment (e.g., Visa, Mastercard)

    @CreationTimestamp
    private LocalDateTime paymentDate;

    @ManyToOne
    @JoinColumn(name = "BILL_ID")
    private Bill bill;

    // Getters and Setters
}
3. DAO Layer (Repositories)
3.1. AddressRepository.java
java
Copy code
@Repository
public interface AddressRepository extends JpaRepository<Address, String> {
}
3.2. CustomerRepository.java (No changes, already in place)
3.3. BillRepository.java (No changes)
3.4. PaymentRepository.java (No changes)
4. Service Layer
4.1. AdminService.java (Updated with address functionality)
java
Copy code
@Service
public interface AdminService {
    Admin login(String username, String password);
    void addCustomer(Customer customer, Address address);
    void editCustomer(Customer customer, Address address);
    void deleteCustomer(String customerId);
    Bill generateBill(Bill bill);
    List<Payment> viewCustomerPayments(String customerId);
    List<Bill> viewPendingPayments(String customerId);
}
4.2. AdminServiceImpl.java (Updated)
java
Copy code
@Service
public class AdminServiceImpl implements AdminService {

    @Autowired
    private AdminRepository adminRepo;

    @Autowired
    private CustomerRepository customerRepo;

    @Autowired
    private AddressRepository addressRepo;

    @Autowired
    private BillRepository billRepo;

    @Autowired
    private PaymentRepository paymentRepo;

    @Override
    public Admin login(String username, String password) {
        return adminRepo.findByUsernameAndPassword(username, password)
                .orElseThrow(() -> new RuntimeException("Invalid admin credentials"));
    }

    @Override
    public void addCustomer(Customer customer, Address address) {
        addressRepo.save(address);
        customer.setAddress(address);
        customerRepo.save(customer);
    }

    @Override
    public void editCustomer(Customer customer, Address address) {
        addressRepo.save(address);
        customer.setAddress(address);
        customerRepo.save(customer);
    }

    @Override
    public void deleteCustomer(String customerId) {
        customerRepo.deleteById(customerId);
    }

    @Override
    public Bill generateBill(Bill bill) {
        return billRepo.save(bill);
    }

    @Override
    public List<Payment> viewCustomerPayments(String customerId) {
        Customer customer = customerRepo.findById(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found"));
        return paymentRepo.findByBillCustomer(customer);
    }

    @Override
    public List<Bill> viewPendingPayments(String customerId) {
        Customer customer = customerRepo.findById(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found"));
        return billRepo.findByCustomerAndStatus(customer, "Pending");
    }
}
4.3. CustomerService.java (No changes)
4.4. CustomerServiceImpl.java (Updated with payment method)
java
Copy code
@Service
public class CustomerServiceImpl implements CustomerService {

    @Autowired
    private CustomerRepository customerRepo;

    @Autowired
    private BillRepository billRepo;

    @Autowired
    private PaymentRepository paymentRepo;

    @Override
    public Customer login(String email, String password) {
        return customerRepo.findByEmailAndPassword(email, password)
                .orElseThrow(() -> new RuntimeException("Invalid customer credentials"));
    }

    @Override
    public Payment makePayment(Payment payment) {
        Bill bill = billRepo.findById(payment.getBill().getBillId())
                .orElseThrow(() -> new RuntimeException("Bill not found"));
        payment.setBill(bill);
        paymentRepo.save(payment);
        bill.setStatus("Paid");
        billRepo.save(bill);
        return payment;
    }

    @Override
    public List<Payment> viewPaymentHistory(String customerId) {
        Customer customer = customerRepo.findById(customerId)
                .orElseThrow(() -> new RuntimeException("Customer not found"));
        return paymentRepo.findByBillCustomer(customer);
    }
}
5. Controller Layer
5.1. AdminController.java (Updated for address functionality)
java
Copy code
@RestController
@RequestMapping("/admin")
public class AdminController {

    @Autowired
    private AdminService adminService;

    @PostMapping("/login")
    public ResponseEntity<Admin> login(@RequestBody Map<String, String> credentials) {
        Admin admin = adminService.login(credentials.get("username"), credentials.get("password"));
        return ResponseEntity.ok(admin);
    }

    @PostMapping("/addCustomer")
    public ResponseEntity<Customer> addCustomer(@RequestBody Map<String, Object> payload) {
        Customer customer = new Customer();
        customer.setCustomerId((String) payload.get("customerId"));
        customer.setName((String) payload.get("name"));
        customer.setEmail((String) payload.get("email"));
        customer.setPhone((String) payload.get("phone"));
        customer.setPassword((String) payload.get("password"));

        Address address = new Address();
        address.setAddressId((String) payload.get("addressId"));
        address.setHouseNumber((String) payload.get("houseNumber"));
        address.setStreetName((String) payload.get("streetName"));
        address.setAreaName((String) payload.get("areaName"));
        address.setCity((String) payload.get("city"));
        address.setState((String) payload.get("state"));
        address.setPincode((String) payload.get("pincode"));

        adminService.addCustomer(customer, address);
        return ResponseEntity.ok(customer);
    }

    @PutMapping("/editCustomer")
    public ResponseEntity<Customer> editCustomer(@RequestBody Map<String, Object> payload) {
        Customer customer = new Customer();
        customer.setCustomerId((String) payload.get("customerId"));
        customer.setName((String) payload.get("name"));
        customer.setEmail((String) payload.get("email"));
        customer.setPhone((String) payload.get("phone"));
        customer.setPassword((String) payload.get("password"));

        Address address = new Address();
        address.setAddressId((String) payload.get






You said:
continue the code
ChatGPT said:
ChatGPT
java
Copy code
        "addressId"));
        address.setHouseNumber((String) payload.get("houseNumber"));
        address.setStreetName((String) payload.get("streetName"));
        address.setAreaName((String) payload.get("areaName"));
        address.setCity((String) payload.get("city"));
        address.setState((String) payload.get("state"));
        address.setPincode((String) payload.get("pincode"));

        adminService.editCustomer(customer, address);
        return ResponseEntity.ok(customer);
    }

    @DeleteMapping("/deleteCustomer/{customerId}")
    public ResponseEntity<String> deleteCustomer(@PathVariable String customerId) {
        adminService.deleteCustomer(customerId);
        return ResponseEntity.ok("Customer deleted successfully");
    }

    @PostMapping("/generateBill")
    public ResponseEntity<Bill> generateBill(@RequestBody Bill bill) {
        Bill generatedBill = adminService.generateBill(bill);
        return ResponseEntity.ok(generatedBill);
    }

    @GetMapping("/viewPayments/{customerId}")
    public ResponseEntity<List<Payment>> viewCustomerPayments(@PathVariable String customerId) {
        List<Payment> payments = adminService.viewCustomerPayments(customerId);
        return ResponseEntity.ok(payments);
    }

    @GetMapping("/viewPendingPayments/{customerId}")
    public ResponseEntity<List<Bill>> viewPendingPayments(@PathVariable String customerId) {
        List<Bill> pendingPayments = adminService.viewPendingPayments(customerId);
        return ResponseEntity.ok(pendingPayments);
    }
}
5.2. CustomerController.java (Updated with address and payment method)
java
Copy code
@RestController
@RequestMapping("/customer")
public class CustomerController {

    @Autowired
    private CustomerService customerService;

    @PostMapping("/login")
    public ResponseEntity<Customer> login(@RequestBody Map<String, String> credentials) {
        Customer customer = customerService.login(credentials.get("email"), credentials.get("password"));
        return ResponseEntity.ok(customer);
    }

    @PostMapping("/makePayment")
    public ResponseEntity<Payment> makePayment(@RequestBody Payment payment) {
        Payment newPayment = customerService.makePayment(payment);
        return ResponseEntity.ok(newPayment);
    }

    @GetMapping("/paymentHistory/{customerId}")
    public ResponseEntity<List<Payment>> viewPaymentHistory(@PathVariable String customerId) {
        List<Payment> paymentHistory = customerService.viewPaymentHistory(customerId);
        return ResponseEntity.ok(paymentHistory);
    }
}
6. Sample Input/Output for Enhanced Functionality
Admin Flow:

Login as admin:
json
Copy code
{
  "username": "admin1",
  "password": "adminpass"
}
Add a customer with address:
json
Copy code
{
  "customerId": "CUST002",
  "name": "Alice Johnson",
  "email": "alice@example.com",
  "phone": "9876543210",
  "password": "password123",
  "addressId": "ADDR001",
  "houseNumber": "12B",
  "streetName": "Baker Street",
  "areaName": "Downtown",
  "city": "New York",
  "state": "NY",
  "pincode": "10001"
}
Generate bill:
json
Copy code
{
  "billId": "BILL002",
  "billMonth": "August",
  "electricityUsed": 450,
  "amount": 900.00,
  "status": "Pending",
  "customerId": "CUST002"
}
Customer Flow:

Login as customer:
json
Copy code
{
  "email": "alice@example.com",
  "password": "password123"
}
Make a payment:
json
Copy code
{
  "paymentId": "PAY002",
  "amountPaid": 900.00,
  "paymentMode": "Debit Card",
  "paymentType": "Visa",
  "billId": "BILL002"
}
View payment history:
bash
Copy code
GET /customer/paymentHistory/CUST002
Relational Mappings
One-to-One Mapping between Customer and Address.
One-to-Many Mapping between Customer and Bill.
Many-to-One Mapping between Payment and Bill.
This enhanced Spring Boot project now includes the detailed customer Address entity and a flexible Payment method functionality, ensuring a robust and professional design. The table names adhere to the required EBS_Table_Name format, and the project is fully compatible with Oracle DB.

Let me know if you need any further modifications or explanations!







Here's how to create the entity classes corresponding to each table in your Oracle database using Spring Boot's JPA. These entities will map to your database tables in a real-time electricity billing system project.

### **1. Customer Entity (EBS_Customer)**

```java
@Entity
@Table(name = "EBS_CUSTOMER")
public class Customer {

    @Id
    @Column(name = "CUSTOMER_ID")
    private String customerId;

    @Column(name = "NAME")
    private String name;

    @Column(name = "EMAIL", unique = true)
    private String email;

    @Column(name = "PHONE")
    private String phone;

    @Column(name = "PASSWORD")
    private String password;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "ADDRESS_ID", referencedColumnName = "ADDRESS_ID")
    private Address address;

    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL)
    private List<Bill> bills;

    // Getters and setters
}
```

### **2. Address Entity (EBS_Address)**

```java
@Entity
@Table(name = "EBS_ADDRESS")
public class Address {

    @Id
    @Column(name = "ADDRESS_ID")
    private String addressId;

    @Column(name = "HOUSE_NUMBER")
    private String houseNumber;

    @Column(name = "STREET_NAME")
    private String streetName;

    @Column(name = "AREA_NAME")
    private String areaName;

    @Column(name = "CITY")
    private String city;

    @Column(name = "STATE")
    private String state;

    @Column(name = "PINCODE")
    private String pincode;

    // Getters and setters
}
```

### **3. Bill Entity (EBS_Bill)**

```java
@Entity
@Table(name = "EBS_BILL")
public class Bill {

    @Id
    @Column(name = "BILL_ID")
    private String billId;

    @Column(name = "BILL_MONTH")
    private String billMonth;

    @Column(name = "ELECTRICITY_USED")
    private int electricityUsed;

    @Column(name = "AMOUNT")
    private double amount;

    @Column(name = "STATUS")
    private String status;  // Pending, Paid

    @ManyToOne
    @JoinColumn(name = "CUSTOMER_ID", referencedColumnName = "CUSTOMER_ID")
    private Customer customer;

    @OneToMany(mappedBy = "bill", cascade = CascadeType.ALL)
    private List<Payment> payments;

    // Getters and setters
}
```

### **4. Payment Entity (EBS_Payment)**

```java
@Entity
@Table(name = "EBS_PAYMENT")
public class Payment {

    @Id
    @Column(name = "PAYMENT_ID")
    private String paymentId;

    @Column(name = "AMOUNT_PAID")
    private double amountPaid;

    @Column(name = "PAYMENT_MODE")
    private String paymentMode;  // e.g., Debit Card, Credit Card, UPI, etc.

    @Column(name = "PAYMENT_TYPE")
    private String paymentType;  // e.g., Visa, MasterCard, etc.

    @ManyToOne
    @JoinColumn(name = "BILL_ID", referencedColumnName = "BILL_ID")
    private Bill bill;

    // Getters and setters
}
```

### **5. Admin Entity (EBS_Admin)**

```java
@Entity
@Table(name = "EBS_ADMIN")
public class Admin {

    @Id
    @Column(name = "ADMIN_ID")
    private String adminId;

    @Column(name = "USERNAME", unique = true)
    private String username;

    @Column(name = "PASSWORD")
    private String password;

    // Getters and setters
}
```

### **6. Database Table Creation Scripts**

Here are the Oracle DB scripts for creating the tables:

#### 1. `EBS_CUSTOMER` Table

```sql
CREATE TABLE EBS_CUSTOMER (
    CUSTOMER_ID VARCHAR2(50) PRIMARY KEY,
    NAME VARCHAR2(100),
    EMAIL VARCHAR2(100) UNIQUE,
    PHONE VARCHAR2(20),
    PASSWORD VARCHAR2(100),
    ADDRESS_ID VARCHAR2(50),
    FOREIGN KEY (ADDRESS_ID) REFERENCES EBS_ADDRESS(ADDRESS_ID)
);
```

#### 2. `EBS_ADDRESS` Table

```sql
CREATE TABLE EBS_ADDRESS (
    ADDRESS_ID VARCHAR2(50) PRIMARY KEY,
    HOUSE_NUMBER VARCHAR2(20),
    STREET_NAME VARCHAR2(100),
    AREA_NAME VARCHAR2(100),
    CITY VARCHAR2(100),
    STATE VARCHAR2(100),
    PINCODE VARCHAR2(10)
);
```

#### 3. `EBS_BILL` Table

```sql
CREATE TABLE EBS_BILL (
    BILL_ID VARCHAR2(50) PRIMARY KEY,
    BILL_MONTH VARCHAR2(20),
    ELECTRICITY_USED NUMBER,
    AMOUNT NUMBER(10, 2),
    STATUS VARCHAR2(20),
    CUSTOMER_ID VARCHAR2(50),
    FOREIGN KEY (CUSTOMER_ID) REFERENCES EBS_CUSTOMER(CUSTOMER_ID)
);
```

#### 4. `EBS_PAYMENT` Table

```sql
CREATE TABLE EBS_PAYMENT (
    PAYMENT_ID VARCHAR2(50) PRIMARY KEY,
    AMOUNT_PAID NUMBER(10, 2),
    PAYMENT_MODE VARCHAR2(50),
    PAYMENT_TYPE VARCHAR2(50),
    BILL_ID VARCHAR2(50),
    FOREIGN KEY (BILL_ID) REFERENCES EBS_BILL(BILL_ID)
);
```

#### 5. `EBS_ADMIN` Table

```sql
CREATE TABLE EBS_ADMIN (
    ADMIN_ID VARCHAR2(50) PRIMARY KEY,
    USERNAME VARCHAR2(100) UNIQUE,
    PASSWORD VARCHAR2(100)
);
```

### **Explanation of Relational Mappings:**

1. **One-to-One Relationship** between `Customer` and `Address`.
   - One customer can have one address.

2. **One-to-Many Relationship** between `Customer` and `Bill`.
   - One customer can have many bills.

3. **Many-to-One Relationship** between `Payment` and `Bill`.
   - One bill can have multiple payments, but each payment is related to only one bill.

### **Service Layer (Service and DAO)**

In the service layer, the service classes (like `AdminServiceImpl`, `CustomerServiceImpl`) interact with these entities and handle business logic such as adding customers, generating bills, making payments, etc.

### **Sample Input/Output:**

- **Adding a Customer:**

    POST `/admin/addCustomer`
    
    ```json
    {
      "customerId": "CUST001",
      "name": "John Doe",
      "email": "john@example.com",
      "phone": "9876543210",
      "password": "pass123",
      "addressId": "ADDR001",
      "houseNumber": "101",
      "streetName": "Main St",
      "areaName": "Greenwood",
      "city": "New York",
      "state": "NY",
      "pincode": "10001"
    }
    ```

- **Generating a Bill:**

    POST `/admin/generateBill`
    
    ```json
    {
      "billId": "BILL001",
      "billMonth": "July",
      "electricityUsed": 350,
      "amount": 750.00,
      "status": "Pending",
      "customerId": "CUST001"
    }
    ```

- **Making a Payment:**

    POST `/customer/makePayment`
    
    ```json
    {
      "paymentId": "PAY001",
      "amountPaid": 750.00,
      "paymentMode": "Credit Card",
      "paymentType": "Visa",
      "billId": "BILL001"
    }
    ```

This complete project structure, including entities and Oracle DB tables, will allow the integration of detailed customer information, payments, and billing operations in a real-world electricity billing system. Let me know if you need further customizations!





Certainly! Continuing from where we left off:

### 7. **Exception Handling (`exception/`)**

**CustomException.java**
```java
package com.example.ebs.exception;

public class CustomException extends RuntimeException {
    public CustomException(String message) {
        super(message);
    }
}
```

**GlobalExceptionHandler.java**
```java
package com.example.ebs.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(CustomException.class)
    public ResponseEntity<String> handleCustomException(CustomException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGlobalException(Exception ex) {
        return new ResponseEntity<>("An unexpected error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### 8. **Configuration (`config/`)**

**SecurityConfig.java**
```java
package com.example.ebs.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
                .antMatchers("/api/admin/**").hasRole("ADMIN")
                .antMatchers("/api/customers/**").hasRole("USER")
                .anyRequest().authenticated()
            .and()
            .formLogin()
                .permitAll()
            .and()
            .httpBasic();
    }

    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers("/h2-console/**");
    }
}
```

### 9. **Spring Boot Application Entry Point**

**EbsApplication.java**
```java
package com.example.ebs;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class EbsApplication {
    public static void main(String[] args) {
        SpringApplication.run(EbsApplication.class, args);
    }
}
```

### 10. **Additional Notes**

1. **Primary Key Generation**
   - Ensure that primary keys are unique strings of length 6. You can customize ID generation in your repository or service layer if necessary.
   - For example, you can use a utility class to generate unique IDs:

**IdGenerator.java**
```java
package com.example.ebs.util;

import java.util.UUID;

public class IdGenerator {
    public static String generateId() {
        return UUID.randomUUID().toString().substring(0, 6).toUpperCase();
    }
}
```

**Usage in Services**
```java
public Customer addCustomer(Customer customer) {
    customer.setId(IdGenerator.generateId());
    return customerRepository.save(customer);
}
```

2. **Testing**
   - Implement unit tests for your service and controller layers to ensure functionality is working as expected. Use JUnit and Mockito for testing.

3. **Frontend Integration**
   - This code does not include frontend implementation. You can use Thymeleaf for server-side rendering or frameworks like React/Angular for a more dynamic user experience.

4. **Database Configuration**
   - Make sure the database configuration in `application.properties` matches your Oracle database setup.

5. **Error Handling**
   - Customize exception handling based on the specific needs of your application.

This setup provides a comprehensive starting point for building an electricity billing system with Spring Boot. Make sure to adapt and extend the code according to your specific project requirements and use cases.
